{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/lookup.cljc"],"mappings":";AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;yDAAA,iEAAAA,1HAAMI,mIA0B6DG;AA1BnE,AAAA,IAAAN,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;UAAAA,NA0B8DK;iBA1B9D,AAAAH,4CAAAF,eAAA,xEA0B8CI;AA1B9C,AA2BE,IAAAG,qBAAc,4GAAA,sGAAA,hNAAM,6BAAA,3BAAI,OAASD,sBAAG,cAAAG,bAAUH,qCAAG,cAAAI,bAASJ,oCAC1C,gDAAA,hDAACK,mFAA2C,AAACC,eAAKN;AADlE,AAAA,oBAAAC;AAAA,AAAA,SAAAA,LAAWC;AAAX,AAEE,0DAAA,mFAAA,+IAAA,rRAACK,+CAAOR,2NAAoDG;;AAF9D","names":["p__44938","map__44946","cljs.core/--destructure-map","cljs.core.get","com.fulcrologic.fulcro.algorithms.lookup/app-algorithm","algorithms","app","k","temp__5753__auto__","nm","cljs.core/Keyword","cljs.core/Symbol","cljs.core.keyword","cljs.core/name","cljs.core.get_in"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.lookup\n  \"Fulcro is quite customizable, and all of the pluggable algorithms are stored on the app. This\n  very easily leads to a desire to alias the long com.fulcrologic.fulcro.application namespace\n  to something like `app` for easy access to keyword aliasing, but in Clojure this leads\n  to circular references. This namespace exists simply to save typing and hassle with\n  respect to that. It includes `app-algorithm` which can look up a plug-in algorithm on\n  an app using a simple keyword without having to require the application ns.\"\n  (:require\n    [taoensso.timbre :as log]))\n\n(defn app-algorithm\n  \"Get the current value of a particular Fulcro plugin algorithm.  These are set by default and can be overridden\n  when you create your fulcro app.\n\n  `app` - The application\n  `k` - the algorithm to obtain. This can be a plain keyword or a symbol of the algorithm desired.\n\n  Supported algorithms that can be obtained/overridden in Fulcro (check the source of app/fulcro-app if you suspect this is out\n  of date, which is likely is):\n\n  - `:global-eql-transform` - A `(fn [tx] tx')` that is applied to all outgoing requests (when using default `tx!`).\n     Defaults to stripping things like `:ui/*` and form state config joins.\n  - `:remote-error?` - A `(fn [result] boolean)` that defines what a remote error is.\n  - `:global-error-action` - A `(fn [env] ...)` that is run on any remote error (as defined by `remote-error?`).\n  - `:optimized-render!` - The concrete render algorithm for optimized renders (not root refreshes)\n  - `:render!` - The top-level render function. Calls root render or optimized render by default. Renders on the calling thread.\n  - `:schedule-render!` - The call that schedules a render. Defaults to using `js/requestAnimationFrame`.\n  - `:default-result-action!` -  The action used for remote results in all mutations that do not have a `result-action` section.\n  - `:index-root!` - The algorithm that scans the current query from root an indexes all classes by their queries.\n  - `:index-component!` - The algorithm that adds a component to indexes when it mounts.\n  - `:drop-component!` - The algorithm that removes a component from indexes when it unmounts.\n  - `:props-middleware` - Middleware that can modify `props` for all components.\n  - `:render-middleware` - Middlware that wraps all `render` methods of `defsc` components.\n\n  Returns nil if the algorithm is currently undefined.\n  \"\n  [{:com.fulcrologic.fulcro.application/keys [algorithms] :as app} k]\n  (when-let [nm (when (or (string? k) (keyword? k) (symbol? k))\n                  (keyword \"com.fulcrologic.fulcro.algorithm\" (name k)))]\n    (get-in app [:com.fulcrologic.fulcro.application/algorithms nm] nil)))\n"]}