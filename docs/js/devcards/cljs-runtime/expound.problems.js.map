{"version":3,"sources":["expound/problems.cljc"],"mappings":"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","names":["expound.problems/adjust-in","form","problem","in1","expound.paths/in-with-kps","in2","paths","expound.paths/paths-to-value","cljs.core._EQ_","cljs.core/count","cljs.core/first","in3","e56085","cljs.spec.alpha/unform","cljs.core/last","_e","new-in","or__4253__auto__","G__56087","fexpr__56086","cljs.core.assoc","expound.problems/adjust-path","failure","and__4251__auto__","G__56093","fexpr__56092","cljs.core/vec","cljs.core/rest","expound.problems/add-spec","spec","expound.problems/fix-via","cljs.core.into","expound.problems/missing-spec?","_failure","expound.problems/not-in-set?","cljs.core/set?","expound.problems/fspec-exception-failure?","cljs.core.not_EQ_","expound.problems/fspec-ret-failure?","expound.problems/fspec-fn-failure?","expound.problems/check-ret-failure?","expound.problems/check-fn-failure?","expound.problems/missing-key?","pred","cljs.core/seq?","cljs.spec.alpha.valid_QMARK_","cljs.core.nth","expound.problems/insufficient-input?","cljs.core/contains?","expound.problems/extra-input?","cljs.spec.alpha/def-impl","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl","cljs.core/any?","cljs.spec.alpha/cat-impl","cljs.spec.alpha/nilable-impl","cljs.core/boolean?","expound.problems/ptype","skip-locations?","cljs.core/not","expound.problems/annotate","explain-data","map__56150","cljs.core/--destructure-map","cljs.core.get","problems","value","args","ret","fn","caller","cljs.core.ex_info","problems'","cljs.core.map","p1__56147#","p1__56148#","cljs.core.comp","cljs.core.partial","expound.problems/type","expound.problems/value-in","expound.paths/value-in"],"sourcesContent":["(ns ^:no-doc expound.problems\n  (:require [expound.paths :as paths]\n            [clojure.spec.alpha :as s])\n  (:refer-clojure :exclude [type]))\n\n;; can simplify when \n;; https://dev.clojure.org/jira/browse/CLJ-2192 or\n;; https://dev.clojure.org/jira/browse/CLJ-2258 are fixed\n(defn- adjust-in [form problem]\n  ;; Three strategies for finding the value...\n  (let [;; 1. Find the original value\n        in1 (paths/in-with-kps form (:val problem) (:in problem) [])\n\n        ;; 2. If value is unique, just find that, ignoring the 'in' path\n        in2 (let [paths (paths/paths-to-value form (:val problem) [] [])]\n              (if (= 1 (count paths))\n                (first paths)\n                nil))\n\n        ;; 3. Find the unformed value (if there is an unformer)\n        in3 (try\n              #?(:bb false\n                 :clj (paths/in-with-kps form\n                                         (s/unform (last (:via problem)) (:val problem))\n                                         (:in problem) [])\n                 :cljs (paths/in-with-kps form\n                                          (s/unform (last (:via problem)) (:val problem))\n                                          (:in problem) [])) \n              ;; The unform fails if there is no unformer\n              ;; and the unform function could throw any type of\n              ;; exception (it's provided by user)\n              (catch #?(:cljs :default\n                        :clj java.lang.Throwable) _e\n                nil))\n        new-in (cond in1\n                     in1\n\n                     in2\n                     in2\n\n                     in3\n                     in3\n\n                     (or (= '(apply fn) (:pred problem))\n                         (#{:ret} (first (:path problem))))\n                     (:in problem)\n\n                     :else\n                     nil)]\n\n    (assoc problem\n           :expound/in\n           new-in)))\n\n(defn- adjust-path [failure problem]\n  (assoc problem :expound/path\n         ;; Orchestra 2019.02.06-1 prefixed the path, but as of 2020.07.12-1, it is not included\n         (if (and (= :instrument failure) (#{:ret :args} (first (:path problem))))\n           (vec (rest (:path problem)))\n           (:path problem))))\n\n(defn- add-spec [spec problem]\n  (assoc problem :spec spec))\n\n;; via is slightly different when using s/assert\n(defn fix-via [spec problem]\n  (if (= spec (first (:via problem)))\n    (assoc problem :expound/via (:via problem))\n    (assoc problem :expound/via (into [spec] (:via problem)))))\n\n(defn ^:private missing-spec? [_failure problem]\n  (= \"no method\" (:reason problem)))\n\n(defn ^:private not-in-set? [_failure problem]\n  (set? (:pred problem)))\n\n(defn ^:private fspec-exception-failure? [failure problem]\n  (and (not= :instrument failure)\n       (not= :check-failed failure)\n       (= '(apply fn) (:pred problem))))\n\n(defn ^:private fspec-ret-failure? [failure problem]\n  (and\n   (not= :instrument failure)\n   (not= :check-failed failure)\n   (= :ret (last (:path problem)))))\n\n(defn ^:private fspec-fn-failure? [failure problem]\n  (and\n   (not= :instrument failure)\n   (not= :check-failed failure)\n   (= :fn (last (:path problem)))))\n\n(defn ^:private check-ret-failure? [failure problem]\n  (and\n   (= :check-failed failure)\n   (= :ret (last (:path problem)))))\n\n(defn ^:private check-fn-failure? [failure problem]\n  (and (= :check-failed failure)\n       (= :fn (last (:path problem)))))\n\n(defn ^:private missing-key? [_failure problem]\n  (let [pred (:pred problem)]\n    (and (seq? pred)\n         (< 2 (count pred))\n         (s/valid?\n          :expound.spec/contains-key-pred\n          (nth pred 2)))))\n\n(defn ^:private insufficient-input? [_failure problem]\n  (contains? #{\"Insufficient input\"} (:reason problem)))\n\n(defn ^:private extra-input? [_failure problem]\n  (contains? #{\"Extra input\"} (:reason problem)))\n\n(s/fdef ptype\n  :args (s/cat :failure (s/nilable #{:instrument :check-failed :assertion-failed})\n               :problem :expound.spec/problem\n               :skip-location? boolean?))\n(defn ^:private ptype [failure problem skip-locations?]\n  (cond\n    (:expound.spec.problem/type problem)\n    (:expound.spec.problem/type problem)\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (fspec-ret-failure? failure problem))\n    :expound.problem/fspec-ret-failure\n\n    (fspec-exception-failure? failure problem)\n    :expound.problem/fspec-exception-failure\n\n    ;; This is really a location of a failure, not a failure type\n    ;; (compare to check-fn-failure, which is also an fn failure, but\n    ;; at a different location)\n    (and (not skip-locations?) (fspec-fn-failure? failure problem))\n    :expound.problem/fspec-fn-failure\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (check-ret-failure? failure problem))\n    :expound.problem/check-ret-failure\n\n    ;; This is really a location of a failure, not a failure type\n    (and (not skip-locations?) (check-fn-failure? failure problem))\n    :expound.problem/check-fn-failure\n\n    (insufficient-input? failure problem)\n    :expound.problem/insufficient-input\n\n    (extra-input? failure problem)\n    :expound.problem/extra-input\n\n    (not-in-set? failure problem)\n    :expound.problem/not-in-set\n\n    (missing-key? failure problem)\n    :expound.problem/missing-key\n\n    (missing-spec? failure problem)\n    :expound.problem/missing-spec\n\n    :else\n    :expound.problem/unknown))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;; public ;;;;;;;;;;;;;;;;;;;;;;;;;\n\n\n(defn annotate [explain-data]\n  (let [{::s/keys [problems value args ret fn failure spec]} explain-data\n        caller (or (:clojure.spec.test.alpha/caller explain-data) (:orchestra.spec.test/caller explain-data))\n        form (if (not= :instrument failure)\n               value\n               (cond\n                 (contains? explain-data ::s/ret) ret\n                 (contains? explain-data ::s/args) args\n                 (contains? explain-data ::s/fn) fn\n                 :else (throw (ex-info \"Invalid explain-data\" {:explain-data explain-data}))))\n        problems' (map (comp (partial adjust-in form)\n                             (partial adjust-path failure)\n                             (partial add-spec spec)\n                             (partial fix-via spec)\n                             #(assoc % :expound/form form)\n                             #(assoc % :expound.spec.problem/type (ptype failure % false)))\n                       problems)]\n\n    (-> explain-data\n        (assoc :expound/form form\n               :expound/caller caller\n               :expound/problems problems'))))\n\n(def type ptype)\n\n;; Must keep this function here because\n;; spell-spec uses it\n;; https://github.com/bhauman/spell-spec/blob/48ea2ca544f02b04a73dc42a91aa4876dcc5fc95/src/spell_spec/expound.cljc#L20\n(def value-in paths/value-in)\n"]}