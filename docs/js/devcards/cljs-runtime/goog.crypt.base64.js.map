{
"version":3,
"file":"goog.crypt.base64.js",
"lineCount":163,
"mappings":"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",
"sources":["goog/crypt/base64.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base64 en/decoding. Not much to say here except that we\n * work with decoded values in arrays of bytes. By \"byte\" I mean a number\n * in [0, 255].\n */\n\ngoog.provide('goog.crypt.base64');\n\ngoog.require('goog.asserts');\ngoog.require('goog.crypt');\ngoog.require('goog.string.internal');\ngoog.require('goog.userAgent');\ngoog.require('goog.userAgent.product');\n\n/**\n * Default alphabet, shared between alphabets. Only 62 characters.\n * @private {string}\n */\ngoog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n    'abcdefghijklmnopqrstuvwxyz' +\n    '0123456789';\n\n\n/**\n * Alphabet characters for Alphabet.DEFAULT encoding.\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '+/=';\n\n\n/**\n * Alphabet characters for Alphabet.WEBSAFE_DOT_PADDING encoding.\n * The dot padding is no Internet Standard, according to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64_URL_SAFE` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS_WEBSAFE =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '-_.';\n\n\n/**\n * Alphabets for Base64 encoding\n * Alphabets with no padding character are for encoding without padding.\n * About the alphabets, please refer to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * @enum {number}\n */\ngoog.crypt.base64.Alphabet = {\n  DEFAULT: 0,\n  NO_PADDING: 1,\n  WEBSAFE: 2,\n  WEBSAFE_DOT_PADDING: 3,\n  WEBSAFE_NO_PADDING: 4,\n};\n\n\n/**\n * Padding chars for Base64 encoding\n * @const {string}\n * @private\n */\ngoog.crypt.base64.paddingChars_ = '=.';\n\n\n/**\n * Check if a character is a padding character\n *\n * @param {string} char\n * @return {boolean}\n * @private\n */\ngoog.crypt.base64.isPadding_ = function(char) {\n  'use strict';\n  return goog.string.internal.contains(goog.crypt.base64.paddingChars_, char);\n};\n\n\n// Static lookup maps, lazily populated by init_()\n\n/**\n * For each `Alphabet`, maps from bytes to characters.\n *\n * @see https://jsperf.com/char-lookups\n * @type {!Object<!goog.crypt.base64.Alphabet, !Array<string>>}\n * @private\n */\ngoog.crypt.base64.byteToCharMaps_ = {};\n\n/**\n * Maps characters to bytes.\n *\n * This map is used for all alphabets since, across alphabets, common chars\n * always map to the same byte.\n *\n * `null` indicates `init` has not yet been called.\n *\n * @type {?Object<string, number>}\n * @private\n */\ngoog.crypt.base64.charToByteMap_ = null;\n\n\n/**\n * White list of implementations with known-good native atob and btoa functions.\n * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code\n * removal in per-browser compilations.\n * @private {boolean}\n */\ngoog.crypt.base64.ASSUME_NATIVE_SUPPORT_ =\n    goog.userAgent.GECKO || goog.userAgent.WEBKIT;\n\n\n/**\n * Does this browser have a working btoa function?\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_ENCODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    typeof(goog.global.btoa) == 'function';\n\n\n/**\n * Does this browser have a working atob function?\n * We blacklist known-bad implementations:\n *  - IE (10+) added atob() but it does not tolerate whitespace on the input.\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_DECODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    (!goog.userAgent.product.SAFARI && !goog.userAgent.IE &&\n     typeof(goog.global.atob) == 'function');\n\n\n/**\n * Base64-encode an array of bytes.\n *\n * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n *     value in [0, 255]) to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeByteArray = function(input, alphabet) {\n  'use strict';\n  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce\n  // size of jscompiler output, and which yields slight performance increase.\n  goog.asserts.assert(\n      goog.isArrayLike(input), 'encodeByteArray takes an array as a parameter');\n\n  if (alphabet === undefined) {\n    alphabet = goog.crypt.base64.Alphabet.DEFAULT;\n  }\n  goog.crypt.base64.init_();\n\n  const byteToCharMap = goog.crypt.base64.byteToCharMaps_[alphabet];\n  const output = new Array(Math.floor(input.length / 3));\n  const paddingChar = byteToCharMap[64] || '';\n\n  // Add all blocks for which we have four output bytes.\n  let inputIdx = 0;\n  let outputIdx = 0;\n  for (; inputIdx < input.length - 2; inputIdx += 3) {\n    const byte1 = input[inputIdx];\n    const byte2 = input[inputIdx + 1];\n    const byte3 = input[inputIdx + 2];\n\n    const outChar1 = byteToCharMap[byte1 >> 2];\n    const outChar2 = byteToCharMap[((byte1 & 0x03) << 4) | (byte2 >> 4)];\n    const outChar3 = byteToCharMap[((byte2 & 0x0F) << 2) | (byte3 >> 6)];\n    const outChar4 = byteToCharMap[byte3 & 0x3F];\n\n    output[outputIdx++] = ((('' + outChar1) + outChar2) + outChar3) + outChar4;\n  }\n\n  // Add our trailing block, in which case we can skip computations relating to\n  // byte3/outByte4.\n  let byte2 = 0;\n  let outChar3 = paddingChar;\n  switch (input.length - inputIdx) {\n    case 2:\n      byte2 = input[inputIdx + 1];\n      outChar3 = byteToCharMap[(byte2 & 0x0F) << 2] || paddingChar;\n      // fall through.\n    case 1:\n      const byte1 = input[inputIdx];\n      const outChar1 = byteToCharMap[byte1 >> 2];\n      const outChar2 = byteToCharMap[((byte1 & 0x03) << 4) | (byte2 >> 4)];\n\n      output[outputIdx] =\n          ((('' + outChar1) + outChar2) + outChar3) + paddingChar;\n      // fall through.\n    default:\n      // We've ended on a block, so we have no more bytes to encode.\n  }\n\n  return output.join('');\n};\n\n\n/**\n * Base64-encode a string.\n *\n * @param {string} input A string to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeString = function(input, alphabet) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !alphabet) {\n    return goog.global.btoa(input);\n  }\n  return goog.crypt.base64.encodeByteArray(\n      goog.crypt.stringToByteArray(input), alphabet);\n};\n\n\n/**\n * Base64-decode a string.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeString = function(input, useCustomDecoder) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !useCustomDecoder) {\n    return goog.global.atob(input);\n  }\n  var output = '';\n  function pushByte(b) {\n    output += String.fromCharCode(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to an Array of numbers.\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.\n * @return {!Array<number>} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {\n  'use strict';\n  var output = [];\n  function pushByte(b) {\n    output.push(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to a Uint8Array.\n *\n * Note that Uint8Array is not supported on older browsers, e.g. IE < 10.\n * @see http://caniuse.com/uint8array\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @return {!Uint8Array} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToUint8Array = function(input) {\n  'use strict';\n  goog.asserts.assert(\n      !goog.userAgent.IE || goog.userAgent.isVersionOrHigher('10'),\n      'Browser does not support typed arrays');\n  var len = input.length;\n  // Approximate the length of the array needed for output.\n  // Our method varies according to the format of the input, which we can\n  // consider in three categories:\n  //   A) well-formed with proper padding\n  //   B) well-formed without any padding\n  //   C) not-well-formed, either with extra whitespace in the middle or with\n  //      extra padding characters.\n  //\n  //  In the case of (A), (length * 3 / 4) will result in an integer number of\n  //  bytes evenly divisible by 3, and we need only subtract bytes according to\n  //  the padding observed.\n  //\n  //  In the case of (B), (length * 3 / 4) will result in a non-integer number\n  //  of bytes, or not evenly divisible by 3. (If the result is evenly divisible\n  //  by 3, it's well-formed with the proper amount of padding [0 padding]).\n  //  This approximation can become exact by rounding down.\n  //\n  //  In the case of (C), the only way to get the length is to walk the full\n  //  length of the string to consider each character. This is handled by\n  //  tracking the number of bytes added to the array and using subarray to\n  //  trim the array back down to size.\n  var approxByteLength = len * 3 / 4;\n  if (approxByteLength % 3) {\n    // The string isn't complete, either because it didn't include padding, or\n    // because it has extra white space.\n    // In either case, we won't generate more bytes than are completely encoded,\n    // so rounding down is appropriate to have a buffer at least as large as\n    // output.\n    approxByteLength = Math.floor(approxByteLength);\n  } else if (goog.crypt.base64.isPadding_(input[len - 1])) {\n    // The string has a round length, and has some padding.\n    // Reduce the byte length according to the quantity of padding.\n    if (goog.crypt.base64.isPadding_(input[len - 2])) {\n      approxByteLength -= 2;\n    } else {\n      approxByteLength -= 1;\n    }\n  }\n  var output = new Uint8Array(approxByteLength);\n  var outLen = 0;\n  function pushByte(b) {\n    output[outLen++] = b;\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  // Return a subarray to handle the case that input included extra whitespace\n  // or extra padding and approxByteLength was incorrect.\n  return output.subarray(0, outLen);\n};\n\n\n/**\n * @param {string} input Input to decode.\n * @param {function(number):void} pushByte result accumulator.\n * @private\n */\ngoog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {\n  'use strict';\n  goog.crypt.base64.init_();\n\n  var nextCharIndex = 0;\n  /**\n   * @param {number} default_val Used for end-of-input.\n   * @return {number} The next 6-bit value, or the default for end-of-input.\n   */\n  function getByte(default_val) {\n    while (nextCharIndex < input.length) {\n      var ch = input.charAt(nextCharIndex++);\n      var b = goog.crypt.base64.charToByteMap_[ch];\n      if (b != null) {\n        return b;  // Common case: decoded the char.\n      }\n      if (!goog.string.internal.isEmptyOrWhitespace(ch)) {\n        throw new Error('Unknown base64 encoding at char: ' + ch);\n      }\n      // We encountered whitespace: loop around to the next input char.\n    }\n    return default_val;  // No more input remaining.\n  }\n\n  while (true) {\n    var byte1 = getByte(-1);\n    var byte2 = getByte(0);\n    var byte3 = getByte(64);\n    var byte4 = getByte(64);\n\n    // The common case is that all four bytes are present, so if we have byte4\n    // we can skip over the truncated input special case handling.\n    if (byte4 === 64) {\n      if (byte1 === -1) {\n        return;  // Terminal case: no input left to decode.\n      }\n      // Here we know an intermediate number of bytes are missing.\n      // The defaults for byte2, byte3 and byte4 apply the inferred padding\n      // rules per the public API documentation. i.e: 1 byte\n      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield\n      // a single byte of output. (Recall that 64 corresponds the padding char).\n    }\n\n    var outByte1 = (byte1 << 2) | (byte2 >> 4);\n    pushByte(outByte1);\n\n    if (byte3 != 64) {\n      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);\n      pushByte(outByte2);\n\n      if (byte4 != 64) {\n        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;\n        pushByte(outByte3);\n      }\n    }\n  }\n};\n\n\n/**\n * Lazy static initialization function. Called before\n * accessing any of the static map variables.\n * @private\n */\ngoog.crypt.base64.init_ = function() {\n  'use strict';\n  if (goog.crypt.base64.charToByteMap_) {\n    return;\n  }\n  goog.crypt.base64.charToByteMap_ = {};\n\n  // We want quick mappings back and forth, so we precompute encoding maps.\n\n  /** @type {!Array<string>} */\n  var commonChars = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split('');\n  var specialChars = [\n    '+/=',  // DEFAULT\n    '+/',   // NO_PADDING\n    '-_=',  // WEBSAFE\n    '-_.',  // WEBSAFE_DOT_PADDING\n    '-_',   // WEBSAFE_NO_PADDING\n  ];\n\n  for (var i = 0; i < 5; i++) {\n    // `i` is each value of the `goog.crypt.base64.Alphabet` enum\n    var chars = commonChars.concat(specialChars[i].split(''));\n\n    // Sets byte-to-char map\n    goog.crypt.base64\n        .byteToCharMaps_[/** @type {!goog.crypt.base64.Alphabet} */ (i)] =\n        chars;\n\n    // Sets char-to-byte map\n    for (var j = 0; j < chars.length; j++) {\n      var char = chars[j];\n\n      var existingByte = goog.crypt.base64.charToByteMap_[char];\n      if (existingByte === undefined) {\n        goog.crypt.base64.charToByteMap_[char] = j;\n      } else {\n        goog.asserts.assert(existingByte === j);\n      }\n    }\n  }\n};\n"],
"names":["goog","provide","require","crypt","base64","DEFAULT_ALPHABET_COMMON_","ENCODED_VALS","ENCODED_VALS_WEBSAFE","Alphabet","DEFAULT","NO_PADDING","WEBSAFE","WEBSAFE_DOT_PADDING","WEBSAFE_NO_PADDING","paddingChars_","isPadding_","goog.crypt.base64.isPadding_","char","string","internal","contains","byteToCharMaps_","charToByteMap_","ASSUME_NATIVE_SUPPORT_","userAgent","GECKO","WEBKIT","HAS_NATIVE_ENCODE_","global","btoa","HAS_NATIVE_DECODE_","product","SAFARI","IE","atob","encodeByteArray","goog.crypt.base64.encodeByteArray","input","alphabet","asserts","assert","isArrayLike","undefined","init_","byteToCharMap","output","Array","Math","floor","length","paddingChar","inputIdx","outputIdx","byte1","byte2","byte3","outChar1","outChar2","outChar3","outChar4","join","encodeString","goog.crypt.base64.encodeString","stringToByteArray","decodeString","goog.crypt.base64.decodeString","useCustomDecoder","pushByte","b","String","fromCharCode","decodeStringInternal_","decodeStringToByteArray","goog.crypt.base64.decodeStringToByteArray","opt_ignored","push","decodeStringToUint8Array","goog.crypt.base64.decodeStringToUint8Array","isVersionOrHigher","len","approxByteLength","Uint8Array","outLen","subarray","goog.crypt.base64.decodeStringInternal_","nextCharIndex","getByte","default_val","ch","charAt","isEmptyOrWhitespace","Error","byte4","outByte1","outByte2","outByte3","goog.crypt.base64.init_","commonChars","split","specialChars","i","chars","concat","j","existingByte"]
}
