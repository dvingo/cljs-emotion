{"version":3,"sources":["dv/cljs_emotion.cljc"],"mappings":"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","names":["dv.cljs-emotion/emotion-hash","dv.cljs_emotion.goog$module$goog$object.get","js/module$node_modules$$emotion$hash$dist$hash_browser_cjs","dv.cljs-emotion/styled","js/module$node_modules$$emotion$styled$dist$emotion_styled_browser_cjs","dv.cljs-emotion/jsx","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.jsx","dv.cljs-emotion/obj-set","o","k","v","dv.cljs_emotion.goog$module$goog$object.set","dv.cljs-emotion/obj-get","dv.cljs-emotion/force-children","x","cljs.core/seq?","cljs.core/to-array","cljs.core.mapv","dv.cljs-emotion/kebab->camel","prop","clojure.string/starts-with?","clojure.string/includes?","words","cljs.core/re-seq","clojure.string/capitalize","cljs.core.update","clojure.string/lower-case","clojure.string.join","dv.cljs-emotion/camelize-keys","style-map","clojure.walk/postwalk","cljs.core/Keyword","cljs.core/name","and__4251__auto__","cljs.core/meta","cljs.core/contains?","dv.cljs-emotion/keyframes","anim-map","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.keyframes","cljs.core/clj->js","dv.cljs-emotion/cljs-props-key","js/goog.define","dv.cljs-emotion/ADD_CLASSNAMES","dv.cljs-emotion/add-class-names?","cljs.core/boolean?","js/goog.DEBUG","dv.cljs-emotion/add-class-name","props","class-name","cljs.core/object?","G__82356","clojure.string/trim","p1__82355#","dv.cljs-emotion/hashit","string","dv.cljs-emotion/set-class-name","hashed-name","dv.cljs-emotion/map->obj","m","cljs.core/reduce-kv","new-k","G__82365","cljs.core/PROTOCOL_SENTINEL","new-v","G__82368","cljs.core/map?","G__82370","dv.cljs-emotion/make-js-props","clj-props","js-props","G__82371","dv.cljs-emotion/react-factory","el","js/module$node_modules$react$index.createElement","e82373","or__4253__auto__","js/module$node_modules$react$index.isValidElement","cljs.core/array?","cljs.core/coll?","js/Object","e","js/console.error","children","cljs.core/not","cljs.core/seq","cljs.core.apply","cljs.core.list_STAR_","dv.cljs-emotion/global*","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.Global","dv.cljs-emotion/global-style","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","dv.cljs-emotion/theme-provider","seq82382","G__82383","cljs.core/first","cljs.core/next","self__4851__auto__","js/Error","js/module$node_modules$$emotion$react$dist$emotion_react_browser_cjs.ThemeProvider"],"sourcesContent":["(ns dv.cljs-emotion\n  (:require\n    #?@(:cljs [[\"react\" :as react]\n               [\"@emotion/hash\" :as emotion-hash*]\n               [\"@emotion/styled\" :as styled*]\n               [\"@emotion/react\" :as styled-core :refer [Global ThemeProvider]]\n               [goog.object :as g]])\n    [clojure.string :as str]\n    [clojure.walk :as walk]\n    [com.fulcrologic.guardrails.core :refer [>defn =>]])\n  #?(:cljs (:require-macros [dv.cljs-emotion :refer [defstyled css]])))\n\n;; Support plain cljs compiler and shadow.\n#?(:cljs (def emotion-hash (g/get emotion-hash* \"default\")))\n#?(:cljs (def styled (g/get styled* \"default\")))\n#?(:cljs (def jsx styled-core/jsx))\n\n;; Used to prevent generated code from needing to require goog.object\n(defn obj-set [o k v]\n  #?(:cljs (g/set o k v)\n     :clj  nil))\n\n(defn obj-get [o k]\n  #?(:cljs (g/get o k)\n     :clj  nil))\n\n;; from fulcro\n#?(:cljs\n   (defn force-children\n     \"Utility function that will force a lazy sequence of children (recursively) into realized\n     vectors (React cannot deal with lazy seqs in production mode)\"\n     [x]\n     (if (seq? x)\n       (to-array (mapv force-children x))\n       x)))\n\n#?(:cljs\n   (>defn kebab->camel\n     [prop]\n     [string? => string?]\n     (if (str/starts-with? prop \".\")\n       prop\n\n       (if (str/includes? prop \"-\")\n         (let [words (->> (re-seq #\"[a-zA-Z]+\" prop)\n                       (mapv str/capitalize))]\n           (-> words\n             (update 0 str/lower-case)\n             str/join))\n         prop))))\n\n;; todo use the caching strategy seen in reagent.impl.template\n\n#?(:cljs\n   (defn camelize-keys\n     \"Also replaces styled components with their css classname is key position.\"\n     [style-map]\n     (walk/postwalk\n       (fn in-walk [v]\n         (cond\n           (keyword? v)\n           (-> v name kebab->camel)\n\n           (and (meta v) (contains? (meta v) ::hashed-name))\n           (str \".\" (-> v meta ::hashed-name))\n\n           :else v))\n       style-map)))\n\n#?(:cljs\n   (defn keyframes [anim-map]\n     (styled-core/keyframes (clj->js (camelize-keys anim-map)))))\n\n(def cljs-props-key \"dv.cljs-emotion/props\")\n\n#?(:clj\n   (defn wrap-call-style-fn [anon-styles?]\n     `(fn [x#]\n        (cond\n\n          ;; Another emotion styled component created with this lib.\n          (and (meta x#) (contains? (meta x#) ::hashed-name))\n          (str \".\" (-> x# meta ::hashed-name))\n\n          (cljs.core/fn? x#)\n          (cljs.core/fn [arg#]\n            ;; arg# is js props passed at runtime, we ship it back and forth js -> cljs -> js\n\n            ;; js->clj is resulting in an infinite recur when children contains another styled component, so we remove it.\n            (cljs.core/js-delete arg# \"children\")\n\n            (if ~anon-styles?\n              ;; with anonymous styles there can be no props - so the theme is passed as the only argument\n              (cljs.core/clj->js (camelize-keys (x# (cljs.core/js->clj arg# :keywordize-keys true))))\n              (let [cljs-args# (assoc (obj-get arg# ~cljs-props-key)\n                                 :theme (cljs.core/js->clj (obj-get arg# \"theme\") :keywordize-keys true))]\n                ;; invoke the user-supplied function which returns style data - convert whatever they return to js data structures.\n                (cljs.core/clj->js (camelize-keys (x# cljs-args#))))))\n\n          ;; maps come up in value position for nested selectors\n          (map? x#)\n          (camelize-keys (cljs.core/js->clj x# :keywordize-keys true))\n\n          :else x#))))\n\n#?(:cljs (goog-define ADD_CLASSNAMES \"INITIAL\"))\n\n#?(:cljs\n   (defn add-class-names? []\n     (if (boolean? ADD_CLASSNAMES)\n       ADD_CLASSNAMES\n       goog.DEBUG)))\n\n#?(:cljs\n   (defn add-class-name [props class-name]\n     (if (object? props)\n       (doto props\n         (goog.object/set \"className\"\n           (->> [class-name (goog.object/get props \"className\")]\n             (str/join \" \")\n             (str/trim))))\n       (update props :className #(if (nil? %) class-name (str class-name \" \" %))))))\n\n#?(:cljs (defn hashit [string] (str \"dvcss-\" (emotion-hash string))))\n\n#?(:cljs\n   (defn set-class-name [props class-name]\n     (if class-name\n       (let [hashed-name (hashit class-name)\n             props       (add-class-name props hashed-name)]\n         (if (add-class-names?)\n           (add-class-name props class-name)\n           props))\n       props)))\n\n#?(:cljs\n   (defn map->obj [m]\n     (reduce-kv (fn [o k v]\n                  ;; convert keywords to string only in key position\n                  (let [new-k (cond-> k (implements? INamed k) name)\n                        new-v (cond-> v (map? v) map->obj)]\n                    (doto o (obj-set new-k new-v))))\n       #js{} m)))\n\n#?(:cljs\n   (defn make-js-props [props class-name]\n     (let [clj-props (set-class-name props class-name)\n           js-props  (map->obj clj-props)]\n       (doto js-props (obj-set cljs-props-key clj-props)))))\n\n#?(:cljs\n   (defn react-factory [el class-name]\n     (fn\n       ([]\n        (react/createElement el (clj->js (set-class-name {} class-name))))\n       ([props]\n        (try\n          (cond\n            (or (react/isValidElement props) (string? props))\n            (react/createElement el (set-class-name #js{} class-name) props)\n\n            (map? props)\n            ;; Do not use clj->js in order to preserve clojure data types like keywords that would not\n            ;; survive a round-trip clj->js js->clj\n            (react/createElement el (make-js-props props class-name))\n\n            (object? props)\n            (react/createElement el (set-class-name props class-name))\n\n            (or (array? props) (coll? props))\n            (react/createElement el (set-class-name #js{} class-name) (force-children props))\n\n            :else\n            (react/createElement el (set-class-name #js{} class-name)))\n\n          (catch js/Object e\n            (js/console.error \"Error invoking an emotion styled component: \" e))))\n\n       ([props & children]\n        ;; if props are a mapping type and not a react child\n        (if (or (and (object? props) (not (react/isValidElement props))) (map? props))\n          (let [js-props (make-js-props props class-name)]\n            (if (seq children)\n              (apply react/createElement el js-props (force-children children))\n              (react/createElement el js-props)))\n          (apply react/createElement el (set-class-name #js{} class-name) (force-children (list* props children))))))))\n\n#?(:clj\n   (defn get-type\n     [styled-arg tag-name]\n     (cond\n       ;; if literals, don't need to determine type at runtime\n       ;; a dom element like :div, same as styled.div``\n       (string? tag-name) `(obj-get ~styled-arg ~tag-name)\n       (keyword? tag-name) `(obj-get ~styled-arg ~(name tag-name))\n       :else\n       `(cond\n          (string? ~tag-name)\n          (obj-get ~styled-arg ~tag-name)\n\n          (keyword? ~tag-name)\n          (obj-get ~styled-arg ~(name tag-name))\n\n          ;; Another styled component\n          (::styled (meta ~tag-name))\n          (.call ~styled-arg ~styled-arg (::styled (meta ~tag-name)))\n\n          ;; A React component\n          :else\n          (.call ~styled-arg ~styled-arg ~tag-name)))))\n\n#?(:clj\n   (defn get-cls-name\n     [namespace-name print-style component-sym]\n     (case print-style\n       :full (str namespace-name \"/\" component-sym)\n       :short (str component-sym)\n       :nil nil)))\n\n#?(:clj (def default-classname-style :full))\n\n#?(:clj\n   (defn get-cls-name-from-meta\n     \"Returns string or nil for the classname\"\n     [namespace-name component-sym]\n     (if (contains? (meta component-sym) :styled/classname)\n       (let [print-config (:styled/classname (meta component-sym))]\n         (if (#{:full :short :nil} print-config)\n           (get-cls-name namespace-name print-config component-sym)\n           (throw (Exception. (str \"Unknown option for class-name style in metadata passed to component: \" component-sym)))))\n       (get-cls-name namespace-name default-classname-style component-sym))))\n\n#?(:clj\n   (defmacro defstyled\n     ([component-name el & children]\n      (let [component-type  (gensym \"component-type\")\n            clss            (gensym \"clss\")\n            class-name      (gensym \"className\")\n            full-class-name (gensym \"fullClassName\")\n            children*       (gensym \"children\")]\n        `(let [~class-name ~(get-cls-name-from-meta (-> &env :ns :name) component-name)\n               ~full-class-name ~(str (-> &env :ns :name) \"/\" component-name)\n\n               ~children*\n               (walk/postwalk\n                 ;; todo here you can do props validation also\n                 ;; should not allow anything that's not a symbol, map, vector, js-obj, js-array, fn\n                 ~(wrap-call-style-fn false)\n                 ~(vec children))\n\n               ;; pass js structures to the lib\n               ~children* (cljs.core/clj->js ~children*)\n               ~component-type ~(get-type `styled el)\n               ~clss (.apply ~component-type ~component-type ~children*)]\n           (obj-set ~clss \"displayName\" ~(str (-> &env :ns :name) \"/\" component-name))\n\n           (def ~component-name\n             (with-meta (react-factory ~clss ~class-name)\n               {::styled      ~clss\n                ::hashed-name (hashit ~full-class-name)}))\n           (cljs.core/specify! ~component-name\n             ;~'IPrintWithWriter\n             ;(~'-pr-writer [this# writer# _#]\n             ;  (~'-write writer# (cljs.core/str this#)))\n             ~'Object\n             (~'toString [this#]\n               (cljs.core/str \".\" (::hashed-name (meta ~component-name))))))))))\n\n#?(:clj\n   (comment\n     (macroexpand-1 '(defstyled button4 button3 {:fontSize \"20em\"}))\n     (macroexpand '(defstyled button3 :button\n                     {:background \"lightblue\" :color \"green\"}))\n\n     (macroexpand-1\n       '(defstyled button3 :button\n          {:background \"lightblue\"\n           button1     {:color \"green\"}}\n          (fn [jsprops cp]\n            {:color (or (:color cp) \"white\")})))\n\n     ;; postwalk doesn't continue expanding replaced values, like the fn call here:\n     (walk/postwalk\n       (fn [i]\n         (cond\n           (fn? i) (i)\n           (keyword? i) (kebab->camel (name i))\n           :else i))\n       [{:background-color \"blue\"}\n        (fn [] {:border-radius 5})])))\n\n(comment\n  (camelize-keys\n    [{:background    \"lightblue\"\n      :font-size     20\n      :border-radius \"10px\"}\n     {:background-image \"url(xyz.com/my-image)\"}])\n  (camelize-keys\n    {:background                \"lightblue\"\n     :font-size                 20\n     \"@media(min-width: 200px)\" {:font-size 33}\n     :border-radius             \"10px\"})\n\n  (walk/postwalk\n    (fn [item]\n      (println \"item: \" item \" map entry: \" (map-entry? item) \" vec? \" (vector? item))\n      (cond\n        (keyword? item)\n        (do\n          (println \"found keyword\")\n          (keyword (kebab->camel (name item))))\n        :elseeeee item)\n      )\n    {:background    \"lightblue\"\n     :font-size     20\n     \"@media(min-width: 200px)\"\n     [{:font-size 33}\n      {:background-color \"purple\"}]\n     :border-radius \"10px\"}))\n\n#?(:cljs\n   (def ^:private global* (react-factory Global nil)))\n\n;; emotion doesn't allow functions in nested position, only\n;; objects and arrays of objects\n;; but they do allow one function as a child\n;; you can always wrap the call in a fn if you want dynamism like below\n;https://github.com/emotion-js/emotion/blob/188dc0e785cfc9b10b3f9a6ead62b56ddd38e039/packages/core/src/global.js#L16\n\n#?(:cljs\n   (defn global-style [props]\n     (global* {:styles (camelize-keys props)})))\n\n;; can use like so:\n(comment\n  (global-style {:body {:background \"#cce\" \"@media (min-width:700px)\" {:background \"white\"}}})\n  (global-style\n    [(clj->js {:body {:font-family \"serif\"}}) {:body {:border \"2px solid yellOW\"}} {:body {:background-color \"#ecccee\"}}])\n\n  ;; to adapt based on props, wrap in a fn:\n  (defn my-globals [props]\n    (global-style\n      {:body {:background-color \"red\"}}))\n  )\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; Theme support\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:cljs\n   (defn theme-provider\n     [props & children]\n     (when-not (contains? props :theme)\n       (throw (js/Error. \"You must pass a :theme to the theme-provider.\")))\n     (apply react/createElement ThemeProvider\n       (clj->js props)\n       (force-children children))))\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n;; CSS prop support\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n\n#?(:clj\n   (defn css-body [props]\n     `(do\n        (assert (contains? ~props :css) \"Props must contain :css key\")\n        (cljs.core/clj->js\n          (assoc ~props :css\n                        (walk/postwalk\n                          ;; todo here you can do props validation also\n                          ;; should not allow anything that's not a symbol, map, vector, js-obj, js-array, fn\n                          ~(wrap-call-style-fn true)\n                          (:css ~props)))))))\n#?(:clj\n   (defmacro css\n     ([el props]\n      (let [el        (cond-> el (keyword? el) name)\n            css-props (css-body props)]\n        `(jsx ~el ~css-props)))\n\n     ([el props children]\n      (let [el        (cond-> el (keyword? el) name)\n            css-props (css-body props)]\n        `(jsx ~el ~css-props ~children)))))\n"]}