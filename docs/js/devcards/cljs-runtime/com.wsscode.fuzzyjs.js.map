{
"version":3,
"file":"com.wsscode.fuzzyjs.js",
"lineCount":150,
"mappings":"AAkBAA,IAAKC,CAAAA,OAAL,CAAa,qBAAb,CAAA;AASAC,GAAIC,CAAAA,OAAQC,CAAAA,OAAQC,CAAAA,kBAApB,GAAyCC,QAAQ,CAACC,OAAD,EAAUC,GAAV,CAAe;AAC5D,MAAIC,aAAa,CAAjB;AACA,MAAIC,SAAS,CAAb;AACA,MAAIC,gBAAgBJ,OAAQK,CAAAA,MAA5B;AACA,MAAIC,YAAYL,GAAII,CAAAA,MAApB;AAEA,SAAOH,UAAP,KAAsBE,aAAtB,IAAuCD,MAAvC,KAAkDG,SAAlD,CAA6D;AACzD,QAAIC,cAAcP,OAAQQ,CAAAA,MAAR,CAAeN,UAAf,CAA2BO,CAAAA,WAA3B,EAAlB;AACA,QAAIC,UAAUT,GAAIO,CAAAA,MAAJ,CAAWL,MAAX,CAAmBM,CAAAA,WAAnB,EAAd;AACA,QAAIF,WAAJ,KAAoBG,OAApB;AACI,QAAER,UAAF;AADJ;AAEA,MAAEC,MAAF;AALyD;AAQ7D,SAAOC,aAAP,KAAyB,CAAzB,IAA8BE,SAA9B,KAA4C,CAA5C,IAAiDJ,UAAjD,KAAgEE,aAAhE;AAd4D,CAAhE;AA2BAT,GAAIC,CAAAA,OAAQC,CAAAA,OAAQc,CAAAA,WAApB,GAAkCC,QAAQ,CAACZ,OAAD,EAAUC,GAAV,CAAe;AAErD,MAAIY,kBAAkB,CAAtB;AACA,MAAIC,kBAAkB,EAAtB;AACA,MAAIC,cAAc,EAAlB;AACA,MAAIC,yBAAyB,CAAC,CAA9B;AACA,MAAIC,6BAA6B,CAAC,CAAlC;AACA,MAAIC,2BAA2B,CAAC,CAAhC;AAGA,MAAIC,QAAQ,CAAZ;AACA,MAAIjB,aAAa,CAAjB;AACA,MAAIE,gBAAgBJ,OAAQK,CAAAA,MAA5B;AACA,MAAIF,SAAS,CAAb;AACA,MAAIG,YAAYL,GAAII,CAAAA,MAApB;AACA,MAAIe,cAAc,KAAlB;AACA,MAAIC,YAAY,KAAhB;AACA,MAAIC,gBAAgB,IAApB;AAGA,MAAIC,aAAa,IAAjB;AACA,MAAIC,YAAY,IAAhB;AACA,MAAIC,gBAAgB,IAApB;AACA,MAAIC,kBAAkB,CAAtB;AAEA,MAAIC,iBAAiB,EAArB;AAGA,SAAOxB,MAAP,KAAkBG,SAAlB,CAA6B;AACzB,QAAIC,cAAcL,UAAA,KAAeE,aAAf,GAA+BJ,OAAQQ,CAAAA,MAAR,CAAeN,UAAf,CAA/B,GAA4D,IAA9E;AACA,QAAIQ,UAAUT,GAAIO,CAAAA,MAAJ,CAAWL,MAAX,CAAd;AAEA,QAAIyB,eAAerB,WAAA,IAAe,IAAf,GAAsBA,WAAYE,CAAAA,WAAZ,EAAtB,GAAkD,IAArE;AACA,QAAIoB,WAAWnB,OAAQD,CAAAA,WAAR,EAAf;AACA,QAAIqB,WAAWpB,OAAQqB,CAAAA,WAAR,EAAf;AAEA,QAAIC,YAAYzB,WAAZyB,IAA2BJ,YAA3BI,KAA4CH,QAAhD;AACA,QAAII,UAAUV,UAAVU,IAAwBT,SAAxBS,KAAsCJ,QAA1C;AAEA,QAAIK,WAAWF,SAAXE,IAAwBX,UAA5B;AACA,QAAIY,gBAAgBZ,UAAhBY,IAA8B5B,WAA9B4B,IAA6CX,SAA7CW,KAA2DP,YAA/D;AACA,QAAIM,QAAJ,IAAgBC,aAAhB,CAA+B;AAC3BhB,WAAA,IAASO,eAAT;AACAC,oBAAeS,CAAAA,IAAf,CAAoBX,aAApB,CAAA;AACAF,gBAAA,GAAa,IAAb;AACAC,eAAA,GAAY,IAAZ;AACAC,mBAAA,GAAgB,IAAhB;AACAC,qBAAA,GAAkB,CAAlB;AAN2B;AAS/B,QAAIM,SAAJ,IAAiBC,OAAjB,CAA0B;AACtB,UAAII,WAAW,CAAf;AAIA,UAAInC,UAAJ,KAAmB,CAAnB;AACEiB,aAAA,IAASmB,IAAKC,CAAAA,GAAL,CAASpC,MAAT,GAAkBa,sBAAlB,EAA0CC,0BAA1C,CAAT;AADF;AAKA,UAAIG,WAAJ;AACIiB,gBAAA,IAAYxB,eAAZ;AADJ;AAIA,UAAIS,aAAJ;AACIe,gBAAA,IAAYvB,eAAZ;AADJ;AAIA,UAAIO,SAAJ,IAAiBX,OAAjB,KAA6BoB,QAA7B,IAAyCD,QAAzC,KAAsDC,QAAtD;AACIO,gBAAA,IAAYtB,WAAZ;AADJ;AAIA,UAAIiB,SAAJ;AACI,UAAE9B,UAAF;AADJ;AAIA,UAAImC,QAAJ,IAAgBX,eAAhB,CAAiC;AAG7B,YAAIH,UAAJ,IAAkB,IAAlB;AACIJ,eAAA,IAASD,wBAAT;AADJ;AAGAK,kBAAA,GAAab,OAAb;AACAc,iBAAA,GAAYD,UAAWd,CAAAA,WAAX,EAAZ;AACAgB,qBAAA,GAAgBtB,MAAhB;AACAuB,uBAAA,GAAkBW,QAAlB;AAT6B;AAYjCjB,iBAAA,GAAc,IAAd;AAtCsB,KAA1B,KAwCK;AAEDoB,kBAAA,IAAgB9B,OAAhB;AAEAS,WAAA,IAASD,wBAAT;AACAE,iBAAA,GAAc,KAAd;AALC;AASLC,aAAA,GAAYX,OAAZ,KAAwBmB,QAAxB,IAAoCA,QAApC,KAAiDC,QAAjD;AACAR,iBAAA,GAAgBZ,OAAhB,KAA4B,GAA5B,IAAmCA,OAAnC,KAA+C,GAA/C;AAEA,MAAEP,MAAF;AA1EyB;AA8E7B,MAAIoB,UAAJ,CAAgB;AACZJ,SAAA,IAASO,eAAT;AACAC,kBAAeS,CAAAA,IAAf,CAAoBX,aAApB,CAAA;AAFY;AAOhB,MAAIe,eAAe,EAAnB;AACA,MAAIC,UAAU,CAAd;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,CAAhB,GAAoBf,cAAetB,CAAAA,MAAnC,EAA2C,EAAEqC,CAA7C,CAAgD;AAC5C,QAAIC,MAAMhB,cAAA,CAAee,CAAf,CAAV;AACAF,gBAAA,IAAgBvC,GAAI2C,CAAAA,MAAJ,CAAWH,OAAX,EAAoBE,GAApB,GAA0BF,OAA1B,CAAhB,GAAqD,WAArD,GAA6DxC,GAAIO,CAAAA,MAAJ,CAAWmC,GAAX,CAA7D,GAA+E,YAA/E;AACAF,WAAA,GAAUE,GAAV,GAAgB,CAAhB;AAH4C;AAKhDH,cAAA,IAAgBvC,GAAI2C,CAAAA,MAAJ,CAAWH,OAAX,EAAoBxC,GAAII,CAAAA,MAAxB,GAAiCoC,OAAjC,CAAhB;AAEA,MAAII,UAAU3C,UAAV2C,KAAyBzC,aAA7B;AACA,SAAO,CAACyC,OAAD,EAAU1B,KAAV,EAAiBqB,YAAjB,CAAP;AA3HqD,CAAzD;AAsIA7C,GAAIC,CAAAA,OAAQC,CAAAA,OAAQiD,CAAAA,qBAApB,GAA4CC,QAAQ,CAACC,OAAD,EAAUhD,OAAV,EAAmBiD,OAAnB,EAA4BC,UAA5B,CAAwC;AACxF,MAAIC,kBAAkB,IAAtB;AAEA,MAAIC,mBAAmB,MAAnBA,GAA0B,IAA9B;AACA,MAAIC,YAAY,CAAhB;AACA,MAAIC,UAAU,EAAd;AACA,MAAIC,gBAAgB,IAApB;AAGAC,UAASA,KAAI,EAAG;AACZC,gBAAA,CAAaF,aAAb,CAAA;AACAA,iBAAA,GAAgB,IAAhB;AAEA,QAAIG,WAAWC,WAAYC,CAAAA,GAAZ,EAAXF,GAA+BN,gBAAnC;AAEA,SAAA,EAAOC,SAAP,GAAmBJ,OAAQ5C,CAAAA,MAA3B,EAAmC,EAAEgD,SAArC,CAAgD;AAC5C,UAAKA,SAAL,GAAiBF,eAAjB,KAAsC,CAAtC;AACI,YAAIQ,WAAYC,CAAAA,GAAZ,EAAJ,GAAwBF,QAAxB,CAAkC;AAC9BH,uBAAA,GAAgBM,UAAA,CAAWL,IAAX,EAAiB,CAAjB,CAAhB;AACA;AAF8B;AADtC;AAOA,UAAIvD,MAAMgD,OAAA,CAAQI,SAAR,CAAV;AACA,UAAIS,SAASd,OAAA,CAAQhD,OAAR,EAAiBC,GAAjB,CAAb;AAGA,UAAI+C,OAAJ,KAAgBrD,GAAIC,CAAAA,OAAQC,CAAAA,OAAQC,CAAAA,kBAApC,IAA0DgE,MAA1D,KAAqE,IAArE;AACIR,eAAQlB,CAAAA,IAAR,CAAanC,GAAb,CAAA;AADJ;AAEK,YAAI+C,OAAJ,KAAgBrD,GAAIC,CAAAA,OAAQC,CAAAA,OAAQc,CAAAA,WAApC,IAAmDmD,MAAA,CAAO,CAAP,CAAnD,KAAiE,IAAjE;AACDR,iBAAQlB,CAAAA,IAAR,CAAa0B,MAAb,CAAA;AADC;AAFL;AAZ4C;AAkBhDZ,cAAA,CAAWI,OAAX,CAAA;AACA,WAAO,IAAP;AAzBY;AA6BhB,MAAIS,SAASA,QAAQ,EAAG;AACpB,QAAIR,aAAJ,KAAsB,IAAtB;AACIE,kBAAA,CAAaF,aAAb,CAAA;AADJ;AADoB,GAAxB;AAQA,MAAIS,QAAQA,QAAQ,EAAG;AACnBR,QAAA,EAAA;AADmB,GAAvB;AAKA,MAAIS,QAAQA,QAAQ,EAAG;AACnBb,oBAAA,GAAmBc,QAAnB;AACAV,QAAA,EAAA;AAFmB,GAAvB;AAKA,SAAO,CAACO,OAAQA,MAAT,EAAiBC,MAAOA,KAAxB,EAA+BC,MAAOA,KAAtC,CAAP;AAxDwF,CAA5F;;",
"sources":["com/wsscode/fuzzyjs.js"],
"sourcesContent":["// LICENSE\n//\n//   This software is dual-licensed to the public domain and under the following\n//   license: you are granted a perpetual, irrevocable license to copy, modify,\n//   publish, and distribute this file as you see fit.\n//\n// VERSION \n//   0.1.0  (2016-03-28)  Initial release\n//\n// AUTHOR\n//   Forrest Smith\n//\n// CONTRIBUTORS\n//   J\u00f8rgen Tjern\u00f8 - async helper\n//   Wilker Lucio - modified to work as a google closure module\n\n\"use strict\";\n\ngoog.provide(\"com.wsscode.fuzzyjs\");\n\n// Returns true if each character in pattern is found sequentially within str\n/**\n * Simple fuzzy match\n * @param {string} pattern The pattern to lookup\n * @param {string} str The string to search into\n * @return {boolean} True if `pattern` matches `str`.\n */\ncom.wsscode.fuzzyjs.fuzzy_match_simple = function(pattern, str) {\n    var patternIdx = 0;\n    var strIdx = 0;\n    var patternLength = pattern.length;\n    var strLength = str.length;\n\n    while (patternIdx !== patternLength && strIdx !== strLength) {\n        var patternChar = pattern.charAt(patternIdx).toLowerCase();\n        var strChar = str.charAt(strIdx).toLowerCase();\n        if (patternChar === strChar)\n            ++patternIdx;\n        ++strIdx;\n    }\n\n    return patternLength !== 0 && strLength !== 0 && patternIdx === patternLength;\n};\n\n// Returns [bool, score, formattedStr]\n// bool: true if each character in pattern is found sequentially within str\n// score: integer; higher is better match. Value has no intrinsic meaning. Range varies with pattern. \n//        Can only compare scores with same search pattern.\n// formattedStr: input str with matched characters marked in <b> tags. Delete if unwanted.\n/**\n * Simple fuzzy match\n * @param {string} pattern The pattern to lookup\n * @param {string} str The string to search into\n */\ncom.wsscode.fuzzyjs.fuzzy_match = function(pattern, str) {\n    // Score consts\n    var adjacency_bonus = 5;                // bonus for adjacent matches\n    var separator_bonus = 10;               // bonus if match occurs after a separator\n    var camel_bonus = 10;                   // bonus if match is uppercase and prev is lower\n    var leading_letter_penalty = -3;        // penalty applied for every letter in str before the first match\n    var max_leading_letter_penalty = -9;    // maximum penalty for leading letters\n    var unmatched_letter_penalty = -1;      // penalty for every letter that doesn't matter\n\n    // Loop variables\n    var score = 0;\n    var patternIdx = 0;\n    var patternLength = pattern.length;\n    var strIdx = 0;\n    var strLength = str.length;\n    var prevMatched = false;\n    var prevLower = false;\n    var prevSeparator = true;       // true so if first letter match gets separator bonus\n\n    // Use \"best\" matched letter if multiple string letters match the pattern\n    var bestLetter = null;\n    var bestLower = null;\n    var bestLetterIdx = null;\n    var bestLetterScore = 0;\n\n    var matchedIndices = [];\n\n    // Loop over strings\n    while (strIdx !== strLength) {\n        var patternChar = patternIdx !== patternLength ? pattern.charAt(patternIdx) : null;\n        var strChar = str.charAt(strIdx);\n\n        var patternLower = patternChar != null ? patternChar.toLowerCase() : null;\n        var strLower = strChar.toLowerCase();\n        var strUpper = strChar.toUpperCase();\n\n        var nextMatch = patternChar && patternLower === strLower;\n        var rematch = bestLetter && bestLower === strLower;\n\n        var advanced = nextMatch && bestLetter;\n        var patternRepeat = bestLetter && patternChar && bestLower === patternLower;\n        if (advanced || patternRepeat) {\n            score += bestLetterScore;\n            matchedIndices.push(bestLetterIdx);\n            bestLetter = null;\n            bestLower = null;\n            bestLetterIdx = null;\n            bestLetterScore = 0;\n        }\n\n        if (nextMatch || rematch) {\n            var newScore = 0;\n\n            // Apply penalty for each letter before the first pattern match\n            // Note: std::max because penalties are negative values. So max is smallest penalty.\n            if (patternIdx === 0) {\n              score += Math.max(strIdx * leading_letter_penalty, max_leading_letter_penalty);\n            }\n\n            // Apply bonus for consecutive bonuses\n            if (prevMatched)\n                newScore += adjacency_bonus;\n\n            // Apply bonus for matches after a separator\n            if (prevSeparator)\n                newScore += separator_bonus;\n\n            // Apply bonus across camel case boundaries. Includes \"clever\" isLetter check.\n            if (prevLower && strChar === strUpper && strLower !== strUpper)\n                newScore += camel_bonus;\n\n            // Update patter index IFF the next pattern letter was matched\n            if (nextMatch)\n                ++patternIdx;\n\n            // Update best letter in str which may be for a \"next\" letter or a \"rematch\"\n            if (newScore >= bestLetterScore) {\n\n                // Apply penalty for now skipped letter\n                if (bestLetter != null)\n                    score += unmatched_letter_penalty;\n\n                bestLetter = strChar;\n                bestLower = bestLetter.toLowerCase();\n                bestLetterIdx = strIdx;\n                bestLetterScore = newScore;\n            }\n\n            prevMatched = true;\n        }\n        else {\n            // Append unmatch characters\n            formattedStr += strChar;\n\n            score += unmatched_letter_penalty;\n            prevMatched = false;\n        }\n\n        // Includes \"clever\" isLetter check.\n        prevLower = strChar === strLower && strLower !== strUpper;\n        prevSeparator = strChar === '_' || strChar === ' ';\n\n        ++strIdx;\n    }\n\n    // Apply score for last match\n    if (bestLetter) {\n        score += bestLetterScore;\n        matchedIndices.push(bestLetterIdx);\n    }\n\n    // Finish out formatted string after last pattern matched\n    // Build formated string based on matched letters\n    var formattedStr = \"\";\n    var lastIdx = 0;\n    for (var i = 0; i < matchedIndices.length; ++i) {\n        var idx = matchedIndices[i];\n        formattedStr += str.substr(lastIdx, idx - lastIdx) + \"<b>\" + str.charAt(idx) + \"</b>\";\n        lastIdx = idx + 1;\n    }\n    formattedStr += str.substr(lastIdx, str.length - lastIdx);\n\n    var matched = patternIdx === patternLength;\n    return [matched, score, formattedStr];\n};\n\n// Strictly optional utility to help make using fts_fuzzy_match easier for large data sets\n// Uses setTimeout to process matches before a maximum amount of time before sleeping\n//\n// To use:\n//      var asyncMatcher = new fts_fuzzy_match(fuzzy_match, \"fts\", \"ForrestTheWoods\", \n//                                              function(results) { console.log(results); });\n//      asyncMatcher.start();\n//\ncom.wsscode.fuzzyjs.fts_fuzzy_match_async = function(matchFn, pattern, dataSet, onComplete) {\n    var ITEMS_PER_CHECK = 1000;         // performance.now can be very slow depending on platform\n\n    var max_ms_per_frame = 1000.0/30.0; // 30FPS\n    var dataIndex = 0;\n    var results = [];\n    var resumeTimeout = null;\n\n    // Perform matches for at most max_ms\n    function step() {\n        clearTimeout(resumeTimeout);\n        resumeTimeout = null;\n\n        var stopTime = performance.now() + max_ms_per_frame;\n\n        for (; dataIndex < dataSet.length; ++dataIndex) {\n            if ((dataIndex % ITEMS_PER_CHECK) === 0) {\n                if (performance.now() > stopTime) {\n                    resumeTimeout = setTimeout(step, 1);\n                    return;\n                }\n            }\n\n            var str = dataSet[dataIndex];\n            var result = matchFn(pattern, str);\n            \n            // A little gross because fuzzy_match_simple and fuzzy_match return different things\n            if (matchFn === com.wsscode.fuzzyjs.fuzzy_match_simple && result === true)\n                results.push(str);\n            else if (matchFn === com.wsscode.fuzzyjs.fuzzy_match && result[0] === true)\n                results.push(result);\n        }\n\n        onComplete(results);\n        return null;\n    }\n\n    // Abort current process\n    var cancel = function() {\n        if (resumeTimeout !== null)\n            clearTimeout(resumeTimeout);\n    };\n\n    // Must be called to start matching.\n    // I tried to make asyncMatcher auto-start via \"var resumeTimeout = step();\" \n    // However setTimout behaving in an unexpected fashion as onComplete insisted on triggering twice.\n    var start = function() {\n        step();\n    };\n\n    // Process full list. Blocks script execution until complete\n    var flush = function() {\n        max_ms_per_frame = Infinity;\n        step();\n    };\n\n    return {cancel: cancel, start: start, flush: flush};\n};\n"],
"names":["goog","provide","com","wsscode","fuzzyjs","fuzzy_match_simple","com.wsscode.fuzzyjs.fuzzy_match_simple","pattern","str","patternIdx","strIdx","patternLength","length","strLength","patternChar","charAt","toLowerCase","strChar","fuzzy_match","com.wsscode.fuzzyjs.fuzzy_match","adjacency_bonus","separator_bonus","camel_bonus","leading_letter_penalty","max_leading_letter_penalty","unmatched_letter_penalty","score","prevMatched","prevLower","prevSeparator","bestLetter","bestLower","bestLetterIdx","bestLetterScore","matchedIndices","patternLower","strLower","strUpper","toUpperCase","nextMatch","rematch","advanced","patternRepeat","push","newScore","Math","max","formattedStr","lastIdx","i","idx","substr","matched","fts_fuzzy_match_async","com.wsscode.fuzzyjs.fts_fuzzy_match_async","matchFn","dataSet","onComplete","ITEMS_PER_CHECK","max_ms_per_frame","dataIndex","results","resumeTimeout","step","clearTimeout","stopTime","performance","now","setTimeout","result","cancel","start","flush","Infinity"]
}
