{"version":3,"sources":["com/fulcrologic/fulcro/algorithms/data_targeting.cljc"],"mappings":"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","names":["cljs.spec.alpha/def-impl","cljs.core/vector?","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","com.fulcrologic.fulcro.algorithms.data-targeting/multiple-targets","seq47341","self__4852__auto__","cljs.core/seq","targets","cljs.core/with-meta","cljs.core/vec","com.fulcrologic.fulcro.algorithms.data-targeting/prepend-to","target","com.fulcrologic.fulcro.algorithms.data-targeting/append-to","com.fulcrologic.fulcro.algorithms.data-targeting/replace-at","com.fulcrologic.fulcro.algorithms.data-targeting/replacement-target?","t","cljs.core/meta","cljs.core/boolean","com.fulcrologic.fulcro.algorithms.data-targeting/prepend-target?","com.fulcrologic.fulcro.algorithms.data-targeting/append-target?","com.fulcrologic.fulcro.algorithms.data-targeting/multiple-targets?","com.fulcrologic.fulcro.algorithms.data-targeting/special-target?","clojure.set.intersection","cljs.core/keys","cljs.core/set","com.fulcrologic.fulcro.algorithms.data-targeting/integrate-ident*","seq47396","G__47397","cljs.core/first","cljs.core/next","G__47398","self__4851__auto__","state","ident","named-parameters","actions","cljs.core.partition","cljs.core.reduce","p__47400","vec__47403","cljs.core.nth","command","data-path","already-has-ident-at-path?","p1__47387#","cljs.core/some","cljs.core._EQ_","cljs.core.get_in","G__47408","cljs.core/Keyword","p1__47390#","cljs.core.update_in","cljs.core.into","cljs.core.fnil","cljs.core/conj","path-to-vector","cljs.core/butlast","to-many?","index","cljs.core/last","vector","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","cljs.core/contains?","cljs.core/assoc-in","G__47433","com.fulcrologic.fulcro.algorithms.data-targeting/process-target","js/Error","state-map","source-path","com.fulcrologic.fulcro.algorithms.data_targeting.process_target","remove-source?","item-to-place","edn-query-language.core/ident?","cljs.core.get","many-idents?","cljs.core/every?","s","process-target-impl","target-has-many?","v","cljs.core.concat","G__47463","com.fulcrologic.fulcro.algorithms.data_targeting.integrate_ident_STAR_","G__47464","and__4251__auto__","cljs.core.dissoc"],"sourcesContent":["(ns com.fulcrologic.fulcro.algorithms.data-targeting\n  \"The implementation of processing load/mutation result graph targeting.\"\n  (:require\n    [clojure.set :as set]\n    [clojure.spec.alpha :as s]\n    [com.fulcrologic.guardrails.core :as gw :refer [>defn => >def]]\n    [edn-query-language.core :as eql]\n    [taoensso.timbre :as log]))\n\n(>def ::target vector?)\n\n(>defn multiple-targets\n  \"Specifies a target that should place edges in the graph at multiple locations.\n\n  `targets` - Any number of targets.  A target can be a simple path (as a vector), or other\n  special targets like `append-to` and `prepend-to`.\"\n  [& targets]\n  [(s/* ::target) => ::target]\n  (with-meta (vec targets) {::multiple-targets true}))\n\n(>defn prepend-to\n  \"Specifies a to-many target that will preprend an edge to some to-many edge. NOTE: this kind of target will not\n  create duplicates in the target list.\n\n  `target` - A vector (path) in the normalized database of the to-many list of idents.\n  \"\n  [target]\n  [::target => ::target]\n  (with-meta target {::prepend-target true}))\n\n(>defn append-to\n  \"Specifies a to-many target that will append an edge to some to-many edge. NOTE: this kind of target will not\n  create duplicates in the target list.\n\n  `target` - A vector (path) in the normalized database of the to-many list of idents.\"\n  [target]\n  [::target => ::target]\n  (with-meta target {::append-target true}))\n\n(>defn replace-at\n  \"Specifies a target that will replace an edge at some normalized location.\n\n  `target` - A vector (path) in the normalized database. This path can include numbers to target some element\n  of an existing to-many list of idents.\"\n  [target]\n  [::target => ::target]\n  (with-meta target {::replace-target true}))\n\n(>defn replacement-target? [t] [any? => boolean?] (-> t meta ::replace-target boolean))\n(>defn prepend-target? [t] [any? => boolean?] (-> t meta ::prepend-target boolean))\n(>defn append-target? [t] [any? => boolean?] (-> t meta ::append-target boolean))\n(>defn multiple-targets? [t] [any? => boolean?] (-> t meta ::multiple-targets boolean))\n\n(>defn special-target?\n  \"Is the given target special? This means it is not just a plain vector path, but is instead something like\n  an append.\"\n  [target]\n  [any? => boolean?]\n  (boolean (seq (set/intersection (-> target meta keys set) #{::replace-target ::append-target ::prepend-target ::multiple-targets}))))\n\n(>defn integrate-ident*\n  \"Integrate an ident into any number of places in the app state. This function is safe to use within mutation\n  implementations as a general helper function.\n\n  The named parameters can be specified any number of times. They are:\n\n  - append:  A vector (path) to a list in your app state where this new object's ident should be appended. Will not append\n  the ident if that ident is already in the list.\n  - prepend: A vector (path) to a list in your app state where this new object's ident should be prepended. Will not place\n  the ident if that ident is already in the list.\n  - replace: A vector (path) to a specific location in app-state where this object's ident should be placed. Can target a to-one or to-many.\n   If the target is a vector element index then that element must already exist in the vector.\n\n  NOTE: `ident` does not have to be an ident if you want to place denormalized data.  It can really be anything.\n\n  Returns the updated state map.\"\n  [state ident & named-parameters]\n  [map? any? (s/* (s/or :path ::target :command #{:append :prepend :replace})) => map?]\n  (let [actions (partition 2 named-parameters)]\n    (reduce (fn [state [command data-path]]\n              (let [already-has-ident-at-path? (fn [data-path] (some #(= % ident) (get-in state data-path)))]\n                (case command\n                  :prepend (if (already-has-ident-at-path? data-path)\n                             state\n                             (update-in state data-path #(into [ident] %)))\n                  :append (if (already-has-ident-at-path? data-path)\n                            state\n                            (update-in state data-path (fnil conj []) ident))\n                  :replace (let [path-to-vector (butlast data-path)\n                                 to-many?       (and (seq path-to-vector) (vector? (get-in state path-to-vector)))\n                                 index          (last data-path)\n                                 vector         (get-in state path-to-vector)]\n                             (when-not (vector? data-path) (log/error \"Replacement path must be a vector. You passed: \" data-path \"See https://book.fulcrologic.com/#err-targ-repl-path-not-vec\"))\n                             (when to-many?\n                               (cond\n                                 (not (vector? vector)) (log/error \"Path for replacement must be a vector. See https://book.fulcrologic.com/#err-targ-multi-repl-must-be-vec\")\n                                 (not (number? index)) (log/error \"Path for replacement must end in a vector index. See https://book.fulcrologic.com/#err-targ-multi-repl-must-end-with-idx\")\n                                 (not (contains? vector index)) (log/error \"Target vector for replacement does not have an item at index \" index \". See https://book.fulcrologic.com/#err-targ-multi-repl-no-such-idx\")))\n                             (assoc-in state data-path ident))\n                  state)))\n      state actions)))\n\n(>defn process-target\n  \"Process a load target (which can be a multiple-target).\n\n  `state-map` - the state-map\n  `source-path` - A keyword, ident, or app-state path.  If the source path is an ident, then that is what is placed\n     in app state.  If it is a keyword or longer path then the thing at that location in app state is pulled from app state\n     and copied to the target location(s).\n  `target` - The target(s)\n  `remove-source?` - When true the source will be removed from app state once it has been written to the new location.\n\n  Returns an updated state-map with the given changes.\"\n  ([state-map source-path target]\n   [map? (s/or :key keyword? :ident eql/ident? :path vector?) ::target => map?]\n   (process-target state-map source-path target true))\n  ([state-map source-path target remove-source?]\n   [map? (s/or :key keyword? :ident eql/ident? :path vector?) ::target boolean? => map?]\n   (letfn [(process-target-impl [state-map source-path target]\n             (let [item-to-place (cond (eql/ident? source-path) source-path\n                                       (keyword? source-path) (get state-map source-path)\n                                       :else (get-in state-map source-path))\n                   many-idents?  (and (vector? item-to-place)\n                                   (every? eql/ident? item-to-place))]\n               (cond\n                 (and (eql/ident? source-path) (not (special-target? target)))\n                 (assoc-in state-map target item-to-place)\n\n                 (not (special-target? target))\n                 (assoc-in state-map target item-to-place)\n\n                 (multiple-targets? target)\n                 (reduce (fn [s t] (process-target-impl s source-path t)) state-map target)\n\n                 (and many-idents? (special-target? target))\n                 (let [state            state-map\n                       target-has-many? (vector? (get-in state target))]\n                   (if target-has-many?\n                     (cond\n                       (prepend-target? target) (update-in state target (fn [v] (vec (concat item-to-place v))))\n                       (append-target? target) (update-in state target (fn [v] (vec (concat v item-to-place))))\n                       :else state)\n                     (assoc-in state target item-to-place)))\n\n                 (special-target? target)\n                 (cond-> state-map\n                   (prepend-target? target) (integrate-ident* item-to-place :prepend target)\n                   (append-target? target) (integrate-ident* item-to-place :append target)\n                   (replacement-target? target) (integrate-ident* item-to-place :replace target))\n\n                 :else (do\n                         (log/warn \"Target processing found an unsupported case. See https://book.fulcrologic.com/#warn-target-unsuported-case\")\n                         state-map))))]\n     (cond-> (process-target-impl state-map source-path target)\n       (and remove-source? (not (eql/ident? source-path))) (dissoc source-path)))))\n"]}